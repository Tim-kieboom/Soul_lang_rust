//comment 1
/*comment 2*/

class StrBuilder {
	str buffer

	Ctor::[](str[] arr) {
		this.buffer = ""

		for el in arr {
			this.buffer += el
		} 
	}

	Ctor() {
		this.buffer = ""
	}

	Len(this@) uint {
		return this.buffer.Len()
	}

	Push(this&, str s) {
		this.buffer += s
	}

	IntoStr(this) str {
		return this.buffer
	}
}

sum(int a, int b) int {
	return a + b
}

sumGeneric<T>(T a, T b) T 
// where 
// 	T: Add 
{
	return a + b
}

struct List{}

tuple() {
	el := 1
	runTimeTuple := (el,2,"hello")
	runTimeTuple1 := (el,2,[1,2,3,],)
	// runTimeTuple2 := (el,(1,2,3,),2)

	(int, bool) tuple = (el, true)
	// (number, condition) := (el, true)
	(field: int, name: bool) namedTuple = (field: el, name: true)
	// (field, name) := (field: el, name: true) 

	functionCall := func(el, 2, "hello")

	runTimeNamedTuple := (field: el, name: "hello")
	ctor := List()
	runTimeNamedTuple2 := List(:)
	runTimeNamedTuple3 := List(field: el, name: "hello")
}

array() {
	array := [int: 1,2,3,4,5,6]
	el := array[0]
	span := array[1..2]
	runTimeArray := [el, 1, 2,]
	runTimeArray1 := [int: el, 1, 2]
	runTimeArray2 := List[el, 1, 2,]
	runTimeArray3 := List[int: el, 1, 2]
	runTimeArray4 := [int:
		el, 
		1, 
		2,
	]

	map := [(str, i32):
		("stuff",  1), 
		("things", 2)
	]

	el2 := [el, 1, 2,][0]

	// runTime2DArray := [[el,1], [1,2,34]]
	// runTime2DArray2 := [int[]; [el,1], [1,2,34]]
	// runTime3DArray := [[[el,1],[1,2]], [[1,2],[2,34]]]
	// runTime3DArray2 := [int[][]; [[el,1],[1,2]], [[1,2],[2,34]]]
}

varDecl() {
	foo := 1
	const f = "hello world"
	Literal fo = (1, 2, 3)
	json := (field: 1, foo: (1, 2, 3), arr: [1,2,3])
	int foo1 = 1
	const int foo2 = 1
	Literal int foo3 = 1 
}

assignment() {
	int foo = 1
	Println(foo)
	foo = 2
	Println(foo)

	foo += 1; foo -= 1; \
	foo *= 1
	foo /= 1
	foo %= 1
	foo |= 1
	foo &= 1
	foo ^= 1
}

ifs() {
	if true {
		Println("true is true")
	}
	else if false {
		Println("false is true")
	}
	else {
		Println("else is true")
	}
}

str parse(this@, int a) int {
	return int(1)	
}

uint sum(this, uint a) uint {
	return this + a
}

int sum(this, int a) int {
	return this + a
}

struct Ref<'a, T> {
	T'a@ inner
}

// Ref<'a, T> Ctor<'a, T>(T'a@ ref) {
// 	return Ref(inner: ref)
// }

type string typeof str

struct Far<T> 
where 
	T: SystemNumber + Add + typeof[int, uint] 
{
	T foo
}

trait Add<O, R = O> {
	Add(this, O other) R
}

typeEnum SystemNumber typeof[int, uint] 

struct Foo<T> { 
	str name
	f32 float = 0.2
	int foo {Get; set;} = 1
	T generic
}

main() int {

	sum(int a, int b) int {
		return a + b 
	}

	for el in [1,2,3,4] {
		Println(el)
	} 

	while 1 == 2 {
		Println("unreachable")		
	}

	sum(1, 2)

	sum(
		1,
		2
	)

	Println("hello world")
}




























