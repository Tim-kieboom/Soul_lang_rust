//comment 1
/*comment 2*/

enum Alphabet {
	A,B,C,D,E,F,G,H,I,
	J,K,L,N,M,O,P,Q,R,
	S,T,U,V,W,X,Y,Z
}

enum NumberedEnum {
	One = 1,
	Two = 0b1010,
	Three = -1,
	Four = 0xff,
}

enumFunc() {
	letter := Alphabet.A
	if letter == Alphabet.A {
		Println(letter)
	}
	else if letter > Alphabet.B {
		Println("ogaboega")
	}
	else if int(letter) > int(NumberedEnum.One) {
		Println("ogaboega (but int)")
	}
}

union Num {
	None(),
	Int(int),
	Uint(num: uint),
	Float(f32),
}

unionFunc() {
	num := Num.Int(1)

	// is_int := num.Tag() == Num.Int.Tag()
	// is_int = num typeof Num.Int

	// if num typeof Num.Int(inner) {

	// }
}


lamdba() {
	// const lamdbaSumTyped = (int a, int b) int => fall a + b
	// // const lamdbaSumHalfTyped = int a, int b => fall a + b
	// // const lamdbaSumReturnTyped = (a, b) int => fall a + b
	// // const lamdbaSum = a, b => fall a + b
	// const increment = a => a += 1
	// const increment = a => a += 1
	// lamdbaSumTyped(1,2)
	// // lamdbaSum(1,2)

	// genericSum<Func: Fn<int,int>int >(Func f)
}

switch() {
	// num := 12
	// match num {
	// 	1 => Println("is 1"),
	// 	21 => Println("is 21"),
	// 	12 => Println("is 12"),
	// 	_ => Println("default"),
	// }

	// string := "num" 
	// match string {
	// 	"num" => Println("yippie"),
	// 	"mun" => Println("eippiy"),
	// 	_ => Println("oh no"),
	// }

// 	tuple := (1, 2, 3)
// 	match tuple {
// 		val if val.0 < val.1 && val.1 < val.2 => Println("ordered"),
// 		val if val.0 > val.1 && val.1 > val.2 => Println("rev ordered"),
// 		_ => Println("not ordered"),
// 	}

	// val := match 1 == 1 {
	// 	true => 12,
	// 	false => {
	// 		f := 21
	// 		f += 1
	// 		fall f
	// 	},
	// }

// 	Num unionName = Num.Int(1)
// 	match unionName {
// 		Int(num) => Println(num),
// 		Uint(num) => Println(num),
// 		Float(num) => Println(num),
// 	} 
}

class StrBuilder {
	// static int runTimeStatic {Get;} = 1
	// Literal int compileTimeStatic {Get;} = 1 

	str buffer

	Ctor::[](str[] arr) {
		this.buffer = ""

		for el in arr {
			this.buffer += el
		} 
	}

	Ctor() {
		this.buffer = ""
	}

	Len(this@) uint {
		return this.buffer.Len()
	}

	Push(this&, str s) {
		this.buffer += s
	}

	IntoStr(this) str {
		return this.buffer
	}
}

testClass() {
	sb := StrBuilder()
	sb = StrBuilder["hello ", "world"]
	len := sb.Len()
	sb.Push(" test")
	Println(sb.IntoStr())
	hash := "str".Hash()
	hash = func().Hash()
	hash = 1.Hash()
}

sum(int a, int b) int {
	return a + b
}

sumGeneric<T>(T a, T b) T 
// where 
// 	T: Add 
{
	return a + b
}


tuple() {
	struct MyList{}

	struct Data{int one; str two}

	el := 1
	runTimeTuple := (el,2,"hello")
	runTimeTuple1 := (el,2,[1,2,3,],)
	
	t := (1,2,3,)
	runTimeTuple2 := (el,t,2)
	runTimeTuple3 := (el,(1,2,3,),2)

	(int, bool) tuple = (el, true)
	int first = tuple.0
	bool second = tuple.1
	// (number, condition) := (el, true)
	(field: int, name: bool) namedTuple = (field: el, name: true)
	// (field, name) := (field: el, name: true) 
	// data = Data(1, "jim")
	// Data(one, two) := data

	functionCall := func(el, 2, "hello")
	functionCall = func(el, 2, "hello", option=1)

	runTimeNamedTuple := (field: el, name: "hello")
	ctor := MyList()
	runTimeNamedTuple2 := MyList(:)
	runTimeNamedTuple3 := MyList(field: el, name: "hello")
}

array() {
	struct MyList{}
	struct MyHashMap{}
	
	array := [int: 1,2,3,4,5,6]
	el := array[0]
	span := array[1..2]
	runTimeArray := [el, 1, 2,]
	runTimeArray1 := [int: el, 1, 2]
	runTimeArray2 := MyList[el, 1, 2,]
	runTimeArray3 := MyList[int: el, 1, 2]
	runTimeArray4 := [int:
		el, 
		1, 
		2,
	]

	map := MyHashMap[(str, i32):
		("stuff",  1), 
		("things", 2)
	]

	el2 := [el, 1, 2,][0]

	runTime2DArray  := [
		[el,1], 
		[1,2,34]
	]
	runTime2DArray2 := [int[]: 
		[1,2,34],
		[el,1], 
	]
	runTime3DArray  := [
		[
			[el,1],
			[1,2]
		], 
		[
			[1,2],
			[2,34]
		]
	]
	runTime3DArray2 := [int[][]: 
		[
			[1,2],
			[2,34],
		],
		[
			[el,1],
			[1,2],
		], 
	]
}

varDecl() {
	struct List{}
	int forwardDecl
	
	let untyped
	untyped = 1 //turns untyped to int from none

	const constUntyped
	constUntyped = 1 //turns untyped to int from none

	list := List[]
	list.Push(1) //turns arr to List<int> from List<none> 

	a := 1
	let b = 1
	const c = "hello world"
	Literal d = (1, 2, 3)


	type MyJson typeof (field: int, foo: (int,int,int), arr: int[])

	json := (field: 1, foo: (1, 2, 3), arr: [1,2,3])
	MyJson typedjson = (field: 1, foo: (1, 2, 3), arr: [1,2,3])
	
	int foo1 = 1
	const int foo2 = 1
	Literal int foo3 = 1 
}

assignment() {
	int foo = 1
	Println(foo)
	foo += 2
	Println(foo)

	foo += 1; foo -= 1; \
	foo *= 1
	foo /= 1
	foo %= 1
	foo |= 1
	foo &= 1
	foo ^= 1
	foo = foo log 100
	foo = foo </ 100
}

ifs() {
	if true {
		Println("true is true")
	}
	else if false {
		Println("false is true")
	}
	else {
		Println("else is true")
	}

	condition := true
	val := condition == true ? 1 : 2

	// Op<i32> num = None
	// if const Some(mut num) typeof num {
	// 	Println(num)
	// } 
}

whiles() {
	
	i := 0
	while i++ < 10 {

		if i % 3 == 0 {
			break
		}

		Println("loop yay")		
	}	
	
	// i = 0
	// imod3 := while {

	// 	if i++ % 3 == 0 {
	// 		break i
	// 	}
	// }

	// stack := List[1,2,3,4]
	// while Some(number) typeof stack.Pop() {
	// 	Println(f"number: {number}")
	// }
}

str parse(this@, int a) int {
	return int(1)	
}

uint sum(this, uint a) uint {
	return this + a
}

int sum(this, int a) int {
	return this + a
}

struct Ref<'a, T> {
	T'a@ inner
}

// Ref<'a, T> Ctor<'a, T>(T'a@ ref) {
// 	return Ref(inner: ref)
// }

type string typeof str

struct Far<T> 
where 
	T: SystemNumber + Add + typeof[int, uint] 
{
	T foo
}

trait Add<O, R = O> {
	Add(this, O other) R
}

typeEnum SystemNumber typeof[int, uint] 

struct Foo<T> { 
	str name
	f32 float = 0.2
	int foo {Get; set;} = 1
	T generic
}

main() int {

	sum(int a, int b) int {
		return a + b 
	}

	for el in [1,2,3,4] {
		Println(el)
	} 

	sum(1, 2)

	sum(
		1,
		2
	)

	Println("hello world")
}




























