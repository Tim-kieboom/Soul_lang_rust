//comment 1
/*comment 2*/

enum Alphabet {
	A,B,C,D,E,F,G,H,I,
	J,K,L,N,M,O,P,Q,R,
	S,T,U,V,W,X,Y,Z
}

enum NumberedEnum {
	One = 1,
	Two = 0b1010,
	Three = -1,
	Four = 0xff,
}

enumFunc() {
	letter := Alphabet.A
	if letter == Alphabet.A {
		Println(letter)
	}
	else if letter > Alphabet.B {
		Println("ogaboega")
	}
	else if int(letter) > int(NumberedEnum.One) {
		Println("ogaboega (but int)")
	}
}

union Num {
	None(),
	Int(int),
	Uint(num: uint),
	Float(f32),
}

unionFunc() {
	printNumInt(Num::Int num) {
		Println(num.0)
	}

	num := Num::Int(1)
	bool is_num = num typeof Num
	bool is_int = num typeof Num::Int

	// if typeof Num::Int(inner) = num {
	// 	Assert(inner typeof int)
	// }
	// else if typeof Num::Uint(num: inner) = num {
	// 	Assert(inner typeof uint)
	// }
	
	// if typeof Num::Int intStruct = num {
	// 	Assert(intStruct typeof Num::Int)

	// 	printNumInt(intStruct)
	// }

	// if typeof Num::Int(inner) = &num {
	// 	Assert(inner typeof &int)
	// }

	// if typeof Num::Int inner = @num {
	// 	Assert(inner typeof @int)
	// }

	// match num {
	// 	Num::None() => Println("none"),
	// 	Num::Int(num) => Println(f"int({num})"),
	// 	Num::Uint(num) => Println(f"uint({num})"),
	// 	Num::Float(num) => Println(f"float({num})"),
	// }

	// match &num {
	// 	Num::None() => Println("none"),
	// 	Num::Int(num) => Println(f"int({num})"),
	// 	Num::Uint(num) => Println(f"uint({num})"),
	// 	Num::Float(num) => Println(f"float({num})"),
	// }

	// match @num {
	// 	Num::Int(num) => Println(f"int({num})"),
	// 	Num::Uint(num) => Println(f"uint({num})"),
	// 	_ => Println("idk")
	// }
}


lamdba() {
	// const lamdbaSumTyped = (int a, int b) int => fall a + b
	// // const lamdbaSumHalfTyped = int a, int b => fall a + b
	// // const lamdbaSumReturnTyped = (a, b) int => fall a + b
	// // const lamdbaSum = a, b => fall a + b
	// const increment = a => a += 1
	// const increment = a => a += 1
	// lamdbaSumTyped(1,2)
	// // lamdbaSum(1,2)

	// genericSum<Func: Fn<int,int>int >(Func f)
}

switch() {
	// num := 12
	// match num {
	// 	1 => Println("is 1"),
	// 	21 => Println("is 21"),
	// 	12 => Println("is 12"),
	// 	_ => Println("default"),
	// }

	// string := "num" 
	// match string {
	// 	"num" => Println("yippie"),
	// 	"mun" => Println("eippiy"),
	// 	_ => Println("oh no"),
	// }

// 	tuple := (1, 2, 3)
// 	match tuple {
// 		val if val.0 < val.1 && val.1 < val.2 => Println("ordered"),
// 		val if val.0 > val.1 && val.1 > val.2 => Println("rev ordered"),
// 		_ => Println("not ordered"),
// 	}

	// val := match 1 == 1 {
	// 	true => 12,
	// 	false => {
	// 		f := 21
	// 		f += 1
	// 		fall f
	// 	},
	// }

// 	Num unionName = Num::Int(1)
// 	match unionName {
// 		Int(num) => Println(num),
// 		Uint(num) => Println(num),
// 		Float(num) => Println(num),
// 	} 
}

class StrBuilder {
	// static int runTimeStatic {Get;} = 1
	// Literal int compileTimeStatic {Get;} = 1 

	str buffer

	Ctor::[](str[] arr) {
		this.buffer = ""

		for el in arr {
			this.buffer += el
		} 
	}

	Ctor() {
		this.buffer = ""
	}

	Len(this@) uint {
		return this.buffer.Len()
	}

	Push(this&, str s) {
		this.buffer += s
	}

	IntoStr(this) str {
		return this.buffer
	}
}

testClass() {
	sb := StrBuilder()
	sb = StrBuilder["hello ", "world"]
	len := sb.Len()
	sb.Push(" test")
	Println(sb.IntoStr())
	hash := "str".Hash()
	hash = func().Hash()
	hash = 1.Hash()
}

sum(int a, int b) int {
	return a + b
}

sumGeneric<T>(T a, T b) T 
// where 
// 	T: Add 
{
	return a + b
}


tuple() {
	struct MyList{}

	struct Data{int one; str two}

	el := 1
	runTimeTuple := (el,2,"hello")
	runTimeTuple1 := (el,2,[1,2,3,],)
	
	t := (1,2,3,)
	runTimeTuple2 := (el,t,2)
	runTimeTuple3 := (el,(1,2,3,),2)

	(int, bool) tuple = (el, true)
	int first = tuple.0
	bool second = tuple.1
	// (number, condition) := (el, true)
	(field: int, name: bool) namedTuple = (field: el, name: true)
	// (field, name) := (field: el, name: true) 
	// data := Data(one: 1, two: "jim")
	// Data(one, two) := data

	functionCall := func(el, 2, "hello")
	functionCall = func(el, 2, "hello", option=1)

	runTimeNamedTuple := (field: el, name: "hello")
	ctor := MyList()
	runTimeNamedTuple2 := MyList(:)
	runTimeNamedTuple3 := MyList(field: el, name: "hello")
}

array() {
	class MyList{
		int[] buffer
		Ctor::[](int[] arr) {
			this.buffer = arr
		}
	}
	type Element typeof (str, i32)
	class MyHashMap{

		Element[] buffer

		Ctor::[](Element[] arr) {
			this.buffer = arr
		}

		Ctor::[]((str, i32)[] arr) {
			this.buffer = arr
		}
	}
	
	array := [int: 1,2,3,4,5,6]
	el := array[0]
	span := array[1..2]
	runTimeArray := [el, 1, 2,]
	runTimeArray1 := [int: el, 1, 2]
	runTimeArray2 := MyList[el, 1, 2,]
	runTimeArray3 := MyList[int: el, 1, 2]
	runTimeArray4 := [int:
		el, 
		1, 
		2,
	]

	// arrayFiller := [for 5 => 0] //returns [0,0,0,0,0]
	// arrayFiller_idx := [for i in 5 => i] // returns [1,2,3,4,5]
	// arrayFiller_2D := [for 5 => [for 2 => 0]] //returns [[0,0],[0,0],[0,0],[0,0],[0,0]]

	map := MyHashMap[(str, i32):
		("stuff",  1), 
		("things", 2)
	]
	map = MyHashMap[Element:
		("stuff",  1), 
		("things", 2)
	]

	el2 := [el, 1, 2,][0]

	runTime2DArray  := [
		[el,1], 
		[1,2,34]
	]
	runTime2DArray2 := [int[]: 
		[1,2,34],
		[el,1], 
	]
	runTime3DArray  := [
		[
			[el,1],
			[1,2]
		], 
		[
			[1,2],
			[2,34]
		]
	]
	runTime3DArray2 := [int[][]: 
		[
			[1,2],
			[2,34],
		],
		[
			[el,1],
			[1,2],
		], 
	]
}

varDecl() {
	struct List{}
	int forwardDecl
	
	let untyped
	untyped = 1 //turns untyped to int from none

	const constUntyped
	constUntyped = 1 //turns untyped to int from none

	list := List[]
	list.Push(1) //turns arr to List<int> from List<none> 

	a := 1
	let b = 1
	const c = "hello world"
	Literal d = (1, 2, 3)


	type MyJson typeof (field: int, foo: (int,int,int), arr: int[])

	json := (field: 1, foo: (1, 2, 3), arr: [1,2,3])
	MyJson typedjson = (field: 1, foo: (1, 2, 3), arr: [1,2,3])
	
	int foo1 = 1
	const int foo2 = 1
	Literal int foo3 = 1 
}

assignment() {
	int foo = 1
	Println(foo)
	foo += 2
	Println(foo)

	foo += 1; foo -= 1; \
	foo *= 1
	foo /= 1
	foo %= 1
	foo |= 1
	foo &= 1
	foo ^= 1
	foo = foo log 100
	foo = foo ** 2
	foo = foo </ 2
}

ifs() {
	if true {
		Println("true is true")
	}
	else if false {
		Println("false is true")
	}
	else {
		Println("else is true")
	}

	condition := true
	val := condition ? 1 : 2
	
	cos1 := true ? 2 log 5
			: false ? 3
			: func()

	con3 := if true {fall 2 log 5} 
			else if false {fall 3}
			else {fall func()}

	// Op<i32> num = None
	// if const Some(mut num) typeof num {
	// 	Println(num)
	// } 
}

rulesets() {

	//default sum
	int[] sum(this@) int {
		sum := 0
		for el in this {
			sum += el
		}
	}

	const int[] _sumIter(this@, uint i, int sum) int {
		return if i >= this.Len() {
			fall sum
		}
		else {
			fall this._sumIter(i+1, sum + this[i])
		}
	}

	//functional sum
	const int[] sum(this@) int {
		return this._sumIter(0, 0)
	}

	//comptime sum
	Literal int[] sum(this@) int {
		//even thou _sumIter is const not Literal it can still be called in Literal ruleset, 
		//because if const gets Literal arguments it becames a Literal function so validats Literal ruleset  
		return this._sumIter(0, 0)
	}

	int[] array = [1,2,3,4,5]
	//default > functional so calls default
	sum := array.sum()

	// //add const to force at least const ruleset (so calls functional)
	// insureConstSum := const array.sum()
	// //add const to force Literal (this will prefere Literal but if all arguments are Literal and there is no Literal func const can also be called)
	// insureLiteralSum := Literal array.sum()

	// defaultBlock := {
	// 	foo := 1
	// 	foo += 1
	// 	fall foo 
	// }

	// constVal := const {
	// 	const f = 1
	// 	const f2 = f + f2
	// 	fall f2 ** 2
	// }

	// compTime := Literal {
	// 	fall 10 log 100
	// }
}

whiles() {
	
	i := 0
	while i++ < 10 {

		if i % 3 == 0 {
			break
		}

		Println("loop yay")		
	}	
	
	// i = 0
	// imod3 := while {

	// 	if i++ % 3 == 0 {
	// 		break i
	// 	}
	// }

	// stack := List[1,2,3,4]
	// while Some(number) typeof stack.Pop() {
	// 	Println(f"number: {number}")
	// }
}

str parse(this@, int a) int {
	return int(1)	
}

uint sum(this, uint a) uint {
	return this + a
}

int sum(this, int a) int {
	return this + a
}

struct Ref<'a, T> {
	T'a@ inner
}

// Ref<'a, T> Ctor<'a, T>(T'a@ ref) {
// 	return Ref(inner: ref)
// }

type string typeof str

struct Far<T> 
where 
	T: SystemNumber + Add + typeof[int, uint] 
{
	T foo
}

trait Add<O, R = O> {
	Add(this, O other) R
}

typeEnum SystemNumber typeof[int, uint] 

struct Foo<T> { 
	str name
	f32 float = 0.2
	int foo {Get; set;} = 1
	T generic
}

main() int {

	sum(int a, int b) int {
		return a + b 
	}

	for el in [1,2,3,4] {
		Println(el)
	} 

	sum(1, 2)

	sum(
		1,
		2
	)

	Println("hello world")
}




























